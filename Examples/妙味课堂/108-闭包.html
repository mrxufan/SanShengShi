<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<style type="text/css">

</style>
</head>
<body>




<script type="text/javascript">
// 函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制收回
// 好处：1、变量长期驻扎在内存中，2、避免全局变量的污染

// function fn1(){
// 	var a=5;
// 	function fn2(){
// 		alert(a);
// 	}
// 	return fn2;
// }
// var fn3=fn1();
// fn3();//5



// var a=10;
// function fn4(){
// 	a++;
// 	alert(a);
// }
// fn4(); //11
// fn4(); //12


// function fn5(){
// 	var a=1;
// 	a++;
// 	alert(a);
// }
// fn5(); //2
// fn5(); //2


// function fn6(){
// 	var a=1;
// 	return function(){
// 		a++;
// 		alert(a);
// 	};
// }
// var fn7=fn6();
// fn7(); //2
// fn7(); //3
// alert(a)//报错，因为此时a是局部变量



// 模块化
// var fn8=(function(){
// 	var a=1;
// 	return function(){
// 		a++;
// 		alert(a);
// 	};
// })();
// fn8(); //2
// fn8(); //3


// var fn9=(function(){
// 	var a=1;
// 	function fn10(){
// 		a++;
// 		alert(a);
// 	}
// 	function fn11(){
// 		a++;
// 		alert(a);
// 	}
// 	return {
// 		b:fn10,
// 		c:fn11
// 	};
// })();
// fn9.b(); //2
// fn9.c(); //3





    function f1() {
        var n = 999;
        nAdd = function () { n++ }
        function f2() {
            alert(n);
        }
        return f2;
    }
    var result = f1()
    // result()//999
    // nAdd()
    // result()//1000

    /*
    在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
    
    为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
    
    这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作
    */


    // 　　var name = "The Window";
    // 　　var object = {
    //     　　　　name: "My Object",
    //     　　　　getNameFunc: function () {
    //         return function () {
    //             return this.name;
    //         };
    //     　　　　}
    // 　　};

    // 　　alert(object.getNameFunc()());//The Window



    // 　　var name = "The Window";
    // 　　var object = {
    //     　　　　name: "My Object",
    //     　　　　getNameFunc: function () {
    //         var that = this;
    //         return function () {
    //             return that.name;
    //         };
    //     　　　　}
    // 　　};

    // 　　alert(object.getNameFunc()());//My Object





</script>
</body>
</html>