<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>es6</title>
</head>
<style>

</style>
<body>
<script>
///////////////////////////////const、let
/*
const声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。否则会报错
let实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效
*/
const num=10;
// num=5;//会报错 console.log(num);

const obj5={
    a:1,
    b:2
}
obj5.a=5//console.log(obj5.a); //5 可以修改对象内部

for(let i=0;i<10;i++){
    // console.log(i);//只在内部有效
}
// console.log(i); //在外部访问会报错

if (true) {
    var a=5;
    // let a=5; 外部访问会报错
}
// console.log(a);


/////////////////////////////////// 箭头函数
var obj6 = {
    a: 10,
    fn1: function () {
        console.log(this.a);
    },
    fn2: function () {
        // console.log(this); //此时this指向obj，因为是被obj调用了

        // var that = this;//把this存起来
        // setTimeout(function () {
        //     console.log(this);//此时this指向window
        //     that.fn1()
        // }, 1000);

        // 可以改成，此时this指向的是fn2这个函数
        setTimeout(() => {
            this.fn1()
        }, 1000);
    }
}
// obj6.fn2()

// 不引入参数
var fn = function () {
    return 1;
} // alert(fn()) 等同于：
var fn1 = () => 2;// alert(fn1());

// 引入单个参数：
var fn2 = x => x; // alert(fn2(3));

// 引入多个参数，则应加上小括号:
var fn3 = (x, y) => x + y;// alert(fn3(2,3))

// 若你想使用标准的函数体，或者函数体内可能有更多的语句要执行，则要用大括号将函数体括起来，并明确定义返回值
var fn4 = (x, y) => { return x + y };//alert(fn4(3,4))


/////////////////////////////////////////对象的扩展Object.keys()、Object.assign()
var obj6={
    a:20,
    // b:function(){
    //     console.log(this.a);
    // },
    
    //可以简写为：省略" : "和function
    b(){
        console.log(this.a);
    }
}
// obj6.b() //20
// console.log(Object.keys(obj6));//获取键名 //["a", "b"]

var obj7={
    c:6
}
// Object.assign(target, ...sources)
var obj8=Object.assign(obj7,obj6);
// console.log(obj8);//{c: 6, a: 20, b: ƒ}

/*
Object.defineProperty(obj, prop, descriptor)
参数：
obj：必需。目标对象
prop：必需。需定义或修改的属性的名字
descriptor：必需。目标属性所拥有的特性
*/
var obj9={};
Object.defineProperty(obj9,'b',{
    value:30,//属性对应的值,可以使任意类型的值，默认为undefined
    writable:false,//属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。
    enumerable:true, //此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。
    configurable:false//是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false
})
obj9.b=10
// console.log(obj9.b);
// console.log(Object.keys(obj9));

delete obj9.b;
// console.log(obj9.b);


/*
getter/setter
getter 是一种获得属性值的方法
setter是一种设置属性值的方法。
在特性中使用get/set属性来定义对应的方法。
*/
var obj10={};
var value1='hello';
Object.defineProperty(obj10,'newValue1',{
    get:function(){
        return value1; ////当获取值的时候触发的函数
    },
    set:function(val){
        // value1=val ////当设置值的时候触发的函数,设置的新值通过参数val拿到
        // console.log(val);
    }
})
// 获取值：
// console.log(obj10.newValue1);//hello
// //设置值
obj10.newValue1='change';
// console.log(obj10.newValue1);//change
/*
注意：
get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined
当使用了getter或setter方法，不允许使用writable和value这两个属性
 */





////////////////////////////////////// 反斜杠模板字符串
var fn5=function(name,age){
    return `姓名：${name}，年龄：${age}`;
}// alert(fn5('张三',30))


////////////////////////////////////////// 更方便的数据访问--解构赋值
// 对象解构
const people={
    name:'张三',
    age:20
}
const {name,age}=people;// console.log(`姓名：${name}，年龄：${age}`);

// 数组解构
// var a1=1;
// var b1=2;
// var c1=3; //可以简写为：
var [a2,b2,c2]=[4,5,6]
// console.log(a2); //4
// 可以嵌套
var [a3,b3,[c3,d3],e3]=[1,2,[3,4],5]
// console.log(c3);

// 字符串解构
var [a,b,c]='你好啊';
// console.log(a);//你

// 应用：
function fn9(/* obj */{a}){
    // console.log(obj.c);
    // console.log(a);
}
fn9({
    a:1,
    b:2,
    c:3
})


///////////////////////////////////////////Spread Operator 展开运算符，“三个点”，（组装对象或者数组）
// 数组：
const color=['red','green'];
const colorfull=[...color,'black','blue'];// console.log(colorfull); //red green black blue
// 对象：
const obj1={name:'张三',age:20};
const obj2={...obj1,sex:'男'}// console.log(obj2);//name: "张三", age: 20, sex: "男"

// 获取数组或者对象除了前几项或者除了某几项的其他项
const number=[1,2,3,4,5];
const [one, two,...reset]=number; //console.log(reset);//3,4,5

const per1={name1:'张三',age1:20,sex1:'男',job1:'designer'};
const {name1,...rest1}= per1; //console.log(rest1);//age1: 20, sex1: "男", job1: "designer"

// 对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边
const obj3={a:1,b:2,c:3};
const obj4={c:4,d:5};
const total={...obj3,...obj4};
// console.log(total);//a: 1, b: 2, c: 4, d: 5

////////////////////////////////////////////////////// class, extends, super
/*
首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的
*/
class Person{
    constructor(name,sex) {
        this.name=name,
        this.sex=sex
    }
    showName(){
        console.log('hello '+this.name);
    }
    // 类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。
    static Methond(){
        return '你好'
    }
}
let per=new Person('柳岩','女');
// console.log(per);//Person {name: "柳岩", sex: "女"}
// per.showName()//hello 柳岩

// console.log(Person.Methond());//你好  不能这样调用：console.log(per.Methond());

/*
Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。下面面定义了一个Per1类，该类通过extends关键字，继承了Person类的所有属性和方法。
super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
*/
class Per1 extends Person{
    constructor(name,sex,age) {
        super(name,sex)
        this.age=age
    }
}
let per2=new Per1('宁静','女',20);
// console.log(per2);//Per1 {name: "宁静", sex: "女", age: 20}
// per2.showName()//hello 宁静

/////////////////////////////////////////////// 不传参数设置默认值
// es5：
function fn6(name){
    name=name||'张三';
    console.log(name);
}
// fn6()//张三
// fn6('李四')//李四

// es6:
function fn7(name='张三'){
    console.log(name);
}
// fn7()//张三
// fn7('李四')//李四

/////////////////////////////////////////////
function fn8(...names){
    console.log(names);
}
// fn8('张三','李四','王五')//["张三", "李四", "王五"]


///////////////////////////////////////////import export，对外导出的必须是一个接口，不能是值，比如：
// export 1 （报错）
// var m=1  export m（报错）

// 正确的写法：
// 写法一：export var m=1;
// 写法二：var m=1;    export{m}
// 写法三：var n=1; export{n as m} 






/////////////////////////////////////////////////////promise
/*
Promise对象可以通过使用then方法将上一步返回的结果获取过来（不管是resolved还是rejected），可以通过使用catch方法捕获Promise对象在使用catch之前的异常。

then方法可以接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果。也就是说，我们在创建这个Promise对象的时候，通过函数resolve传递出去的结果可以被第一个then方法中的第一个函数捕获然后作为它的参数。通过函数reject传递出去的结果可以被第一个then方法中的第二个函数捕获然后作为它的参数

*/
var promise1=new Promise((resolve, reject) => {
    var num= Math.random().toFixed(2);
    console.log(`num:${num}(如果num>0.5执行resolve，否则执行reject)`);
    if (num>0.5) {
        resolve('成功')
    } else {
        reject('失败')
    }
})
console.log(promise1); //Promise {<resolved>: "成功"} 或 Promise {<rejected>: "失败"}
// promise1.then((str)=>{
//     console.log(str); //成功（接受resolve的结果）
// }).catch((err)=>{
//     console.log(err); //失败（接受reject的结果）
// }) 

//或者：
promise1.then((success) => {
    console.log(success); //成功（接受resolve的结果）
},(error) => {
    console.log(error); //失败（接受reject的结果）
})
</script>
</body>
</html>