<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>继承模式、命名空间、对象枚举</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>


<script type="text/javascript">

Father.prototype.laetName='Deng';
function Father(){

}
function Son(){

}

function inherit(target,origin){
	target.prototype=origin.prototype;
}
inherit(Son,Father);
Son.prototype.firstName='Mr';//此时Son加属性Father也跟着加，因为他们都指向同一个prototype
var son1=new Son(); //son1.laetName->Deng, son1.firstName->Mr
var father1=new Father(); //father1.laetName->Deng, son1.firstName->Mr



/*
F最为一个中间层，此时Son.prototype既可以继承Father又可以添加自己的属性而不影响到Father
Father.prototype
	function F(){}
	F.prototype=Father.prototype
	Son.prototype=new F()

*/


// 圣杯模式
function inherit1(target,origin){
	function F(){}
	F.prototype=origin.prototype;
	target.prototype=new F();
	target.prototype.constuctor=target;
	// target.prototype.uber=origin.prototype; 真正继承的是谁
}

Person.prototype.firstName='mr';
function Person(){

}
function Student(){

}
inherit1(Student,Person);
Student.prototype.lastName='xu';//此时Student添加自己的prototype，不影响Person
var person1=new Person(); //person1.firstName->mr,person1.lastName->undefined
var student1=new Student(); //student1.firstName->mr,student1.lastName->xu



// Person.prototype.firseName='xu';
// function Person(name,sex){
//     this.name=name;
//     this.sex=sex;
// }



// var per1=new Person('张三','李四');
// function F(){};
// F.prototype=Person.prototype;
// per1.prototype=new F();




// 管理变量，防止全局污染，适用于模块化开发

// 命名空间，老办法
var obj={
	list1:{
		zs:{
			name:'张三',
			age:20
		}
	},
	list2:{
		ls:{
			name:'李四',
			age:30
		}
	}
};
var myObj=obj.list1.zs;
// myObj.name->张三

// obj.list1.zs.name->张三
// obj.list2.ls.name->李四




var name='张三';
var init=(function(){
	var name='李四';
	function callName(){
		console.log(name);
	};
	return function(){
		callName();
	};
	// 形成一个闭包，
}());

var initDeng=(function(){
	var name='王五';
	function callName(){
		console.log(name);
	}
	return function(){
		callName();
	};
}());

// init()//->李四
// initDeng()//->王五





// 实现方法的链式调用：return this
var zhang={
	eat:function(){
		console.log('烧鸡');
		// return zhang
		return this;
	},
	drink:function(){
		console.log('可乐');
	}
};
// zhang.eat().drink(); //烧鸡 可乐







/*
属性表示方法：
	obj.prop
	obj['prop']
*/

var mrDeng={
	wife1:{name:'小张'},
	wife2:{name:'小王'},
	wife3:{name:'小刘'},
	wife4:{name:'小李'},
	sayWife:function(num){
		return this['wife'+num];
	}
};
mrDeng.sayWife(1)// 小张
mrDeng.sayWife(2)// 小王
mrDeng.sayWife(3)// 小刘
mrDeng.sayWife(4)// 小李








var obj1={
	name:'张三',
	age:20,
	sex:'男',
	height:170,
	__proto__:{
		lastName:'李四'
	}
};
for (prop in obj1) {
	// console.log(prop); //name age sex height
	// console.log(obj1[prop]); //张三 20 男 170
	// if (obj1.hasOwnProperty(prop)) {
	// 	console.log(obj1[prop]);
	// }
}






/*
A instanceof B
instanceof->A对象是不是B构造函数构造出来的
看A对象的原型链上有没有B的原型
*/

function Person2(){

}
var person2=new Person2();
// console.log(person2 instanceof Person2); //true




</script>  
</body>
</html>