<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>闭包</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<style type="text/css">

</style>
</head>
<body>


<script type="text/javascript">


/////////////////////闭包实现累加器，不依赖外部变量
// function add(){
// 	var num=0;
// 	function f1(){
// 		num++;
// 		console.log(num);
// 	}
// 	return f1;
// }
// var result=add();
// result(); //1
// result(); //2
// result(); //3




// function test(){
//     var food='apple';
//     var obj={
//         eatFood:function(){
//             if (food!='') {
//                 console.log('I am eating '+food);
//                 food='';
//             } else {
//                 console.log('There is empty');
//             }
//         },
//         pushFood:function(myFood){
//             food=myFood;
//         }
//     };
//     return obj;
// } 
// var person=test(); 
// person.eatFood(); //I am eating apple
// person.eatFood(); //There is empty
// person.pushFood('banner');
// person.eatFood(); //I am eating banner



// function fn(){
// 	var arr=[];
// 	for (var i = 0; i < 10; i++) {
// 		arr[i]=function(){
// 			console.log(i);
// 			document.write(i+' ');
// 		};
// 	}
// 	return arr;
// }
// var myArr=fn();
// for(var j=0;j<10;j++){
// 	myArr[j](); //10个10
// }

////////解决闭包问题:在外面套一层立即执行函数，此时立即执行函数里面的j对应的是立即执行函数传过来的j
// function fn(){
// 	var arr=[];
// 	for (var i = 0; i < 10; i++) {
// 		(function(j){
// 			arr[j]=function(){
// 				document.write(j+' ');
// 			};
// 		}(i));
// 	}
// 	return arr;
// }
// var myArr=fn();
// for(var j=0;j<10;j++){
// 	myArr[j](); //0 1 2 3 4 5 6 7 8 9
// }



//////////////////////////立即执行函数，只有表达式才能被执行，只执行一次，执行完立即销毁
// (function(a,b){
// 	console.log(a+b);
// }(1,2));

// 立即执行函数返回值
// var num=(function(a,b){
// 	return a+b;
// }(2,3));
// console.log(num); //5


</script>    
</body>
</html>